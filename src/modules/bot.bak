import { Path, RNG } from 'rot-js';

import * as world from './world';
import * as player from './player-system';
import * as effects from './effects';
import * as tiles from '../data/tiles';
import * as events from './events';
import * as display from './display';

import {
  COLLECTABLES,
  CWALLS,
  KROZ,
  MAGIC_TRIGGERS,
  TBLOCKS,
  TRIGGERABLES,
  Type,
} from '../data/tiles';
import type { Entity } from '../classes/entity';
import {
  Collectible,
  isPushable,
  Position,
  Walkable,
} from '../classes/components';


const COLLECT = [
  ...COLLECTABLES,
  Type.Key,
  Type.Nugget,
  Type.Amulet,
  Type.Tablet,
];

type Moves = [Entity, number, number];
type Weights = Record<string, number>;

// TODO: Reset on level change
const VISITED = new Map<string, number>();
let dijkstra: Path.Dijkstra;

events.levelStart.add(() => {
  VISITED.clear();
});

let neighbors = [] as Array<Moves>;

function getNeighbors(x: number, y: number) {
  const n: Array<Moves> = [];
  const R = 1;
  for (let dx = -R; dx <= R; dx++) {
    for (let dy = -R; dy <= R; dy++) {
      const [xx, yy] = [x + dx, y + dy];
      const e = world.level.map.get(xx, yy);
      if (!e) continue;
      n.push([e, xx, yy]);
    }
  }
  return n;
}

function isWalkable(e: Entity) {
  return e?.has(Walkable) ||
    e?.type === Type.BlockSpell ||
    TBLOCKS.includes(e?.type as Type) ||
    TBLOCKS.includes(e?.type as Type) ||
    CWALLS.includes(e?.type as Type) ||
    MAGIC_TRIGGERS.includes(e?.type as Type) ||
    TRIGGERABLES.includes(e?.type as Type);
}

function getUnexploredNeighborhood(x: number, y: number) {
  const n = getNeighbors(x, y);
  return n.filter((n) => {
    const [e,  xx, yy] = n;
    if (!isWalkable(e)) return false;
    const id = `${xx}.${yy}`;
    return !VISITED.has(id);
  });
}

function chebyshevDistance(x1: number, y1: number, x2: number, y2: number) {
  return Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2));
}

async function pickMove(moves: Weights): Promise<boolean> {
  const p = world.level.player.get(Position)!;
  if (!p) return false;

  const id = RNG.getWeightedValue(moves);
  if (id) {
    const [x, y] = id.split('.');
    await tryMove(+x, +y);
    return true;
  }
  return false;
}

async function toStairs(): Promise<boolean> {
  const p = world.level.player.get(Position)!;
  if (!p) return false;

  const stairs = neighbors.filter((n) => n[0].type === Type.Stairs);
  if (stairs.length < 1) return false;

  const weights = stairs.reduce(
    (acc, n) => {
      const [,x, y] = n;
      acc[`${x}.${y}`] = 1 / (chebyshevDistance(p.x, p.y, x, y) + 1);
      return acc;
    },
    {} as Record<string, number>,
  );

  console.log('toStairs');
  return pickMove(weights);
}

async function toCollect() {
  const p = world.level.player.get(Position)!;
  if (!p) return false;

  const collect = neighbors.filter((n) => {
    return (
      COLLECT.includes(n[0]?.type as Type) ||
      n[0].has(Collectible) ||
      KROZ.includes(n[0].type as Type)
    );
  });
  if (collect.length < 1) return false;

  const weights = collect.reduce(
    (acc, n) => {
      const [e,x,y] = n;
      acc[`${x}.${y}`] = 1 / (chebyshevDistance(p.x, p.y, x, y) + 1) + tiles.getScoreDelta(e.type as Type);
      return acc;
    },
    {} as Record<string, number>,
  );

  console.log('toCollect');
  return pickMove(weights);
}

async function toOpenDoor() {
  if (world.stats.keys < 1) return false;

  const p = world.level.player.get(Position)!;
  if (!p) return false;

  const keys = neighbors.filter((n) => n[0].type === Type.Door);
  if (keys.length < 1) return false;

  const weights = keys.reduce(
    (acc, n) => {
      const [,x, y] = n;
      acc[`${x}.${y}`] = 1 / (chebyshevDistance(p.x, p.y, x, y) + 1);
      return acc;
    },
    {} as Record<string, number>,
  );

  console.log('toOpenDoor');
  return pickMove(weights);
}

async function explore() {
  const p = world.level.player.get(Position)!;
  if (!p) return false;

  const unexploredNeighbors = getUnexploredNeighborhood(p.x, p.y);
  if (unexploredNeighbors.length < 1) return false;

  const weights = unexploredNeighbors.reduce(
    (acc, n) => {
      const [,x, y] = n;
      const u = getUnexploredNeighborhood(x, y);
      acc[`${x}.${y}`] = u.length + 1;
      return acc;
    },
    {} as Record<string, number>,
  );

  console.log('explore');
  return pickMove(weights);
}

async function toPush() {  // TODO: Need to avoid pushing rocks that cannot be pushed
  const p = world.level.player.get(Position)!;
  if (!p) return false;

  const rocks = neighbors.filter((n) => n[0]?.has(isPushable));
  if (rocks.length < 1) return false;

  const weights = rocks.reduce(
    (acc, n) => {
      const [,x, y] = n;
      acc[`${x}.${y}`] = 1 / (chebyshevDistance(p.x, p.y, x, y) + 1);
      return acc;
    },
    {} as Weights,
  );

  console.log('toPush');
  return pickMove(weights);
}

async function whip() {
  if (world.stats.whips < 1) return false;
  if (Math.random() > (0.05 * world.stats.whips)) return false;

  const p = world.level.player.get(Position)!;
  if (!p) return;

  const breakable = neighbors.filter((n) => n[0]?.type === Type.Block);
  if (breakable.length < 1) return false;

  console.log('whip');
  world.stats.whips--;
  await effects.whip();
  return true;
}

async function teleport() {
  if (world.stats.teleports < 1) return false;
  if (Math.random() > (0.001 * world.stats.teleports)) return false;

  console.log('teleport');
  world.stats.teleports--;
  player.move(...(await effects.teleport()));
  return true;
}

async function search() {
  const p = world.level.player.get(Position)!;
  if (!p) return;

  const emptySpace = neighbors.filter(m => isWalkable(m[0]));
  if (emptySpace.length < 1) return false;

  const weights = emptySpace.reduce(
    (acc, n) => {
      const [,x, y] = n;
      const id = `${x}.${y}`;
      const visits = VISITED.get(id) || 0.001;
      acc[`${x}.${y}`] = 1 / visits;
      return acc;
    },
    {} as Weights,
  );

  console.log('search');
  return pickMove(weights);
}

function passableCallback(x: number, y: number) {
  const e = world.level.map.get(x, y);
  if (!e) return false;
  return isWalkable(e);
}

// Random Bot
export async function botPlay() {
  const p = world.level.player.get(Position)!;
  if (!p) return;

  const dijkstra = new Path.Dijkstra(p.x, p.y, passableCallback, { topology: 8});

  const map = world.level.map;
  const keys = [] as Array<Moves>;
  for (let x = 0; x < map.width; x++) {
    for (let y = 0; y < map.height; y++) {
      const e = world.level.map.get(x, y);
      if (!e) continue;
      if (e.type === Type.Key) {
        keys.push([e, x, y]);
      }
    }
  }

  const path = [];
  dijkstra.compute(keys[0][1], keys[0][2], (x, y) => {
    path.push([x, y]);
  });

  console.log(path);

  return;

  neighbors = getNeighbors(p.x, p.y);

  if (await toStairs()) return;
  if (await toCollect()) return;
  if (await explore()) return;
  if (await toOpenDoor()) return;
  if (await toPush()) return;
  if (await whip()) return;
  if (await teleport()) return;
  if (await search()) return;
  return;
}

async function tryMove(x: number, y: number) {
  const p = world.level.player.get(Position)!;
  if (!p) return false;
  const id = `${x}.${y}`;
  const visited = VISITED.get(id);
  VISITED.set(id, visited ? visited + 1 : 1);
  await player.tryMove(+x - p.x, +y - p.y);
}
